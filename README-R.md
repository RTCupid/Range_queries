# Решение задачи диапазонных запросов в C++ с использованием красно-чёрного дерева

<div align="center">

![C++](https://img.shields.io/badge/C++-23-blue?style=for-the-badge&logo=cplusplus)
![CMake](https://img.shields.io/badge/CMake-3.20+-green?style=for-the-badge&logo=cmake)
![Testing](https://img.shields.io/badge/Google_Test-Framework-red?style=for-the-badge&logo=google)

</div>

## Ознакомьтесь с [Руководством по вкладу](contribution_guidelines.md)

## Другие языки

1. [Русский](/README-R.md)
2. [Английский](/README.md)

## Содержание
- [1. Установка и сборка](#установка-и-сборка)
- [2. Задача диапазонных запросов](#задача-диапазонных-запросов)
- [3. Введение](#введение)
- [4. Реализация красно-чёрного дерева](#реализация-красно-чёрного-дерева)
- [5. Структура проекта](#структура-проекта)
- [6. Требования](#требования)
- [7. Авторы проекта](#авторы-проекта)

## Установка и сборка

Для установки, компиляции и запуска выполните:
```bash
git clone git@github.com:RTCupid/Range_queries.git
cd Range_queries
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cd build
cmake --build .
./Range_queries
```

Для запуска модульных тестов выполните:
```bash
ctest
```

Тесты включают в себя 2 вида тестирований (unit и end_to_end).
Для их запуска по отдельности выполните:
```bash
ctest -L unit
ctest -L end_to_end
```

Для генерации тестов предусмотрен генератор (путь: ./build/tests/end_to_end/generator).
Сгенерированные тесты будут прогнанны в end_to_end тестировании.
Для его запуска введите:
```bash
./generator [количество тестов в тестирующем файле] [количество тестирующих файлов]
```

Для сборки в режиме отладки:
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug
cd build
cmake --build .
./Range_queries
```

Следующие флаги cmake используются для выбора структуры данных и измерения времени выполнения:

| Флаг           | Тип / Значения                | По умолчанию | Назначение                                                   | Поведение в коде                                                                  |
| -------------- | ----------------------------- | ------------ | ------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| `RB_TREE_RUN`     | bool: `ON`/`OFF` | `ON`  | Включает реализацию на основе кастомного красно-чёрного дерева | Компилирует и выполняет код под `#ifdef RB_TREE_RUN` |
| `STD_SET_RUN`     | bool: `ON`/`OFF` | `OFF` | Включает реализацию на основе `std::set`                      | Компилирует и выполняет код под `#ifdef STD_SET_RUN`  |
| `RB_TREE_LOG_RUN` | bool: `ON`/`OFF` | `OFF` | Включает реализацию на основе кастомного красно-чёрного дерева со своим log_distance вместо std::distance | Компилирует и выполняет код под `#ifdef RB_TREE_LOG_RUN`  |
| `TIMING_RUN`   | bool: `ON`/`OFF`    | `OFF`  | Включает вывод времени выполнения (измерение производительности) | Активирует вывод или логику, связанную со временем, под `#if TIMING_RUN`|

Для удобства использования создано 6 таргетов, в которых уже по умолчанию расставлены флаги выше:
| Цель                     | Что делает                                                         | Включённые флаги                         |
|--------------------------|--------------------------------------------------------------------|------------------------------------------|
| `Range_queries_rb_tree`          | Основная реализация диапазонных запросов на основе красно-чёрного дерева | `RB_TREE_RUN`                            |
| `Range_queries_rb_tree_time`     | Красно-чёрное дерево с измерением времени выполнения        | `RB_TREE_RUN`, `TIMING_RUN`              |
| `Range_queries_std_set`          | Реализация диапазонных запросов на основе `std::set`        | `STD_SET_RUN`                            |
| `Range_queries_std_set_time`     | `std::set` с измерением времени выполнения                  | `STD_SET_RUN`, `TIMING_RUN`              |
| `Range_queries_rb_tree_log`      | Красно-чёрное дерево с кастомным методом log_distance (для ускорения)| `RB_TREE_LOG_RUN`                        |
| `Range_queries_rb_tree_log_time` | Красно-чёрное дерево с кастомным методом log_distance (для ускорения) и измерением времени    | `RB_TREE_LOG_RUN`, `TIMING_RUN`          |


## Задача диапазонных запросов

- Диапазонные запросы удобны для данных, хранящихся в дереве.
- Пусть вход содержит `keys` (каждый ключ — целое число, все ключи различны) и `queries` (каждый запрос — пара целых чисел, второе число больше первого).
- Для каждого запроса нужно подсчитать количество ключей, лежащих строго между его границами, включительно.
- Пример входа: `k 10 k 20 q 8 31 q 6 9 k 30 k 40 q 15 40`.
- Результат: `2 0 3`.

## Введение

Диапазонные запросы — важная операция в современной вычислительной технике, широко используемая в базах данных, финансовых системах и аналитике данных. Они помогают находить записи в пределах определённых значений, например клиентов с покупками от $100 до $500 или транзакции в определённом диапазоне для обнаружения мошенничества. Такие системы требуют эффективной обработки постоянно изменяющихся данных.

Простое решение — хранить ключи в массиве и проверять каждый элемент на каждом запросе. Однако этот подход становится очень медленным при больших объёмах данных, поскольку время обработки растёт линейно. Это делает метод непригодным для систем реального времени.

Более эффективное решение использует *красно-чёрные деревья* — самобалансирующиеся бинарные деревья поиска, поддерживающие эффективность операций с помощью правил раскраски и поворотов. Каждый узел может хранить размер поддерева, что делает возможным выполнение диапазонных запросов за логарифмическое время вместо линейного. Это даёт значительный прирост производительности в масштабируемых системах.

## Реализация красно-чёрного дерева

В проекте реализовано собственное красно-чёрное дерево, являющееся самобалансирующимся бинарным деревом поиска. Структура предназначена для эффективных операций вставки, поиска и выполнения диапазонных запросов. Реализация поддерживает логарифмическое время работы всех ключевых операций благодаря строгим правилам балансировки.

### Ключевые особенности реализации

- Полный контроль над структурой данных — дерево реализовано без использования std::set или других стандартных контейнеров, что позволило гибко расширить функциональность, включая хранение размера поддерева и логирование.

- Поддержка диапазонных запросов — каждый узел хранит размер своего поддерева, что позволяет за O(log⁡n) вычислять количество элементов в произвольном диапазоне.

- Балансировка через повороты и перекрашивание — полностью реализованы классические правила красно-чёрного дерева: орень всегда чёрный, красный узел не может иметь красного родителя, все пути от узла до листьев содержат одинаковое количество чёрных узлов.

### Основные файлы реализации
#### node.hpp

Содержит описание структуры узла дерева:
- значение ключа;
- цвет узла (красный/чёрный);
- указатели на родителя и детей;
- вспомогательное поле — размер поддерева (subtree_size), используемое для диапазонных запросов;
- служебные методы для обновления размера поддерева.

#### tree.hpp

Определяет основной класс RedBlackTree, включающий:
- операции вставки с полной реализацией алгоритма fix-up (перекрашивание, левый/правый поворот);
- операции поиска;
- обновление размеров поддеревьев при каждом изменении структуры;
- вспомогательные методы для навигации: min_node, max_node, successor, predecessor;
- публичный интерфейс, позволяющий использовать дерево как контейнер ключей.

#### iterator.hpp

Реализует двунаправленный итератор, совместимый со стандартной моделью итераторов C++:
- переход к следующему и предыдущему элементу;
- сравнение итераторов;
- разыменование значения узла;
- корректная работа в рамках структуры красно-чёрного дерева.

Итератор используется для интеграции дерева в высокоуровневый интерфейс диапазонных запросов.

#### range_query.hpp

Определяет логику обработки запросов вида:
```bash
q L R
```

## Структура проекта

*(Раздел может быть дополнен вашим проектом.)*

## Требования
- C++23 или новее  
- CMake 3.20+  
- Google Test (для тестирования)  
- Graphviz (необязательно, для визуализации)

## Авторы проекта

<div align="center">

<a href="https://github.com/RTCupid">
  <img src="https://raw.githubusercontent.com/BulgakovDmitry/3D_triangles/main/img/A.jpeg" width="160" height="160" style="border-radius: 50%;">
</a>
<a href="https://github.com/BulgakovDmitry">
  <img src="https://raw.githubusercontent.com/BulgakovDmitry/3D_triangles/main/img/D.jpeg" width="160" height="160" style="border-radius: 50%;">
</a>
<br>
<a href="https://github.com/RTCupid"><strong>@RTCupid, </strong></a>
<a href="https://github.com/BulgakovDmitry"><strong>@BulgakovDmitry</strong></a>
<br>

</div>
